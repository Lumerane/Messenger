[{"name":"Messenger.Audio.Audio","comment":"\n\n\n# Audio Module\n\nYou can play audio by emitting `SOMPlayAudio` message with the audio ID, a channel, and an option.\n\nThe channel is an integer that is used to identify the audio channel.\n\nYou **can** play different audio on the same channel at the same time. The previous audio will not be stopped.\n\nHowever, when you stop the channel, all audio on the channel will be stopped.\n\nIf an audio is finished playing, it will be removed from the playing channel.\n\n@docs newAudioChannel\n\n","unions":[],"aliases":[],"values":[{"name":"newAudioChannel","comment":" Generate a new unique audio channel number.\n","type":"Messenger.Base.GlobalData userdata -> Basics.Int"}],"binops":[]},{"name":"Messenger.Audio.Base","comment":"\n\n\n# Audio Base\n\n@docs AudioOption\n\n","unions":[{"name":"AudioOption","comment":" You can play one audio once or loop it.\n","args":[],"cases":[["ALoop",[]],["AOnce",[]]]}],"aliases":[],"values":[],"binops":[]},{"name":"Messenger.Base","comment":"\n\n\n# Base Module\n\nSome Basic Data Types for the game\n\n@docs WorldEvent\n@docs UserEvent\n@docs GlobalData, InternalData, loadedResourceNum\n@docs Env\n@docs Flags\n@docs removeCommonData, addCommonData\n@docs UserViewGlobalData\n@docs emptyInternalData, userGlobalDataToGlobalData, globalDataToUserGlobalData\n\n","unions":[{"name":"UserEvent","comment":" User Event\n\nThis is the User Event for the game.\n\nUsers can get outside information through these events.\n\n`Tick` is triggered every timeInterval.\n\n`KeyDown`, `KeyUp` records the keyboard events.\ncheck all the keycodes [here](https://www.toptal.com/developers/keycode).\n\n`MouseDown`, `MouseUp` records the button code and position when mouse up and down.\nMouse code 0 represents the left mouse button, 1 represents middle mouse button and 2 represents\nright mouse button.\n\nWe have provide some key and mouse codes in messenger-extra.\n\n`MouseWheel` records the wheel event for mouse, positive value means sroll down while\nnegative value means scroll up. It can be also used for touchpad.\n\n`Prompt name result` gives the result user entered in the prompt window.\n\n","args":[],"cases":[["Tick",["Basics.Int"]],["KeyDown",["Basics.Int"]],["KeyUp",["Basics.Int"]],["MouseDown",["Basics.Int","( Basics.Float, Basics.Float )"]],["MouseUp",["Basics.Int","( Basics.Float, Basics.Float )"]],["MouseWheel",["Basics.Int"]],["Prompt",["String.String","String.String"]]]},{"name":"WorldEvent","comment":" World Event\n\nThis is the World Event for the game.\n\nThe events that messenger will receive from outside\n\nBasically users don't need to deal with the world events, they work with user events instead.\n\n","args":[],"cases":[["WTick",["Time.Posix"]],["WKeyDown",["Basics.Int"]],["WKeyUp",["Basics.Int"]],["NewWindowSize",["( Basics.Float, Basics.Float )"]],["WindowVisibility",["Browser.Events.Visibility"]],["SoundLoaded",["String.String","Result.Result Audio.LoadError Audio.Source"]],["TextureLoaded",["String.String","Maybe.Maybe Canvas.Texture.Texture"]],["WMouseDown",["Basics.Int","( Basics.Float, Basics.Float )"]],["WMouseUp",["Basics.Int","( Basics.Float, Basics.Float )"]],["MouseMove",["( Basics.Float, Basics.Float )"]],["WMouseWheel",["Basics.Int"]],["WPrompt",["String.String","String.String"]],["NullEvent",[]]]}],"aliases":[{"name":"Env","comment":" Environment\n\nEnvironment is provided to users almost all the time.\n\nIt stores GlobalData and CommonData (Similar to GlobalData but just for one scene),\nso you can get and modify them through the Env.\n\n","args":["common","userdata"],"type":"{ globalData : Messenger.Base.GlobalData userdata, commonData : common }"},{"name":"Flags","comment":" The main flags.\n\nGet info from js script.\n\n**Learn more about flags [here](https://guide.elm-lang.org/interop/flags)**\n\n","args":[],"type":"{ windowWidth : Basics.Float, windowHeight : Basics.Float, timeStamp : Basics.Int, info : String.String }"},{"name":"GlobalData","comment":" GlobalData\n\nGlobalData is the data that doesn't change during the game.\n\nIt won't be reset if you change the scene.\n\nIt is mainly used for display and reading/writing some localstorage data.\n\n  - `globalStartFrame` records the past frames number since the game started\n  - `globalStartTime` records the past time since the game started, in milliseconds\n  - `sceneStartFrame` records the past frames number since this scene started\n  - `sceneStartTime` records the past time since this scene started, in milliseconds\n  - `userdata` records the data that users set to save\n  - `extraHTML` is used to render extra HTML tags. Be careful to use this\n  - `windowVisibility` records whether users stay in this tab/window\n  - `pressedKeys` records the keycodes that are be pressed now\n  - `pressedMouseButtons` records the mouse buttons that are pressed now\n  - `volume` records the volume of the game\n  - `currentScene` records the current scene name\n  - `mousePos` records the mouse position, in virtual coordinate\n\n","args":["userdata"],"type":"{ internalData : Messenger.Base.InternalData, sceneStartTime : Basics.Int, globalStartTime : Basics.Int, globalStartFrame : Basics.Int, sceneStartFrame : Basics.Int, currentTimeStamp : Time.Posix, windowVisibility : Browser.Events.Visibility, mousePos : ( Basics.Float, Basics.Float ), pressedMouseButtons : Set.Set Basics.Int, pressedKeys : Set.Set Basics.Int, extraHTML : Maybe.Maybe (Html.Html Messenger.Base.WorldEvent), canvasAttributes : List.List (Html.Attribute Messenger.Base.WorldEvent), volume : Basics.Float, userData : userdata, currentScene : String.String }"},{"name":"InternalData","comment":" Internal GlobalData\n\nBasically users do not need to get or modify them.\n\n  - `browserViewPort` records the browser size.\n  - `sprites` records all the sprites(images).\n\n","args":[],"type":"{ browserViewPort : ( Basics.Float, Basics.Float ), realWidth : Basics.Float, realHeight : Basics.Float, startLeft : Basics.Float, startTop : Basics.Float, sprites : Dict.Dict String.String Canvas.Texture.Texture, virtualWidth : Basics.Float, virtualHeight : Basics.Float, audioRepo : Messenger.Audio.Internal.AudioRepo }"},{"name":"UserViewGlobalData","comment":" This type is for user to use when initializing the messenger.\n","args":["userdata"],"type":"{ sceneStartTime : Basics.Int, globalStartTime : Basics.Int, sceneStartFrame : Basics.Int, globalStartFrame : Basics.Int, volume : Basics.Float, extraHTML : Maybe.Maybe (Html.Html Messenger.Base.WorldEvent), canvasAttributes : List.List (Html.Attribute Messenger.Base.WorldEvent), userData : userdata }"}],"values":[{"name":"addCommonData","comment":" Add the common data to a Environment without common data.\n","type":"cdata -> Messenger.Base.Env () userdata -> Messenger.Base.Env cdata userdata"},{"name":"emptyInternalData","comment":" Empty InternalData\n","type":"Messenger.Base.InternalData"},{"name":"globalDataToUserGlobalData","comment":" Translate GlobalData to UserViewGlobalData\n","type":"Messenger.Base.GlobalData userdata -> Messenger.Base.UserViewGlobalData userdata"},{"name":"loadedResourceNum","comment":" Get the number of loaded resources.\n","type":"Messenger.Base.GlobalData userdata -> Basics.Int"},{"name":"removeCommonData","comment":" Remove common data from environment.\n\nUseful when dealing with portable components by yourself.\n\nMost of the time it will not be used since it has been built into prepared update functions.\n\n","type":"Messenger.Base.Env cdata userdata -> Messenger.Base.Env () userdata"},{"name":"userGlobalDataToGlobalData","comment":" Translate UserViewGlobalData to GlobalData\n","type":"Messenger.Base.UserViewGlobalData userdata -> Messenger.Base.GlobalData userdata"}],"binops":[]},{"name":"Messenger.Component.Component","comment":"\n\n\n# Component\n\nA component is an object that you may put in your layers.\n\n\n## User components\n\nThese are components that you users can create with custom **basedata**.\n\nBasedata is the data that components with the same type can share.\n\nFor example, you may want a game component to have some common properties like position, velocity, etc.\n\nIn this case, your basedata would be a record with these properties.\n\n@docs AbstractComponent\n@docs ConcreteUserComponent\n@docs genComponent\n@docs updateComponents, updateComponentsWithBlock\n@docs updateComponentsWithTarget\n\n\n## View components\n\n@docs genComponentsRenderList, viewComponentsRenderList\n@docs viewComponents\n\n\n# Type sugar\n\n@docs ComponentInit, ComponentUpdate, ComponentUpdateRec, ComponentView, ComponentMatcher\n@docs ComponentStorage, LevelComponentStorage\n\n","unions":[],"aliases":[{"name":"AbstractComponent","comment":" Abstract component\n","args":["cdata","userdata","tar","msg","bdata","scenemsg"],"type":"Messenger.GeneralModel.AbstractGeneralModel (Messenger.Base.Env cdata userdata) Messenger.Base.UserEvent tar msg ( Canvas.Renderable, Basics.Int ) bdata (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"ComponentInit","comment":" Component init type sugar\n","args":["cdata","userdata","msg","data","bdata"],"type":"Messenger.Base.Env cdata userdata -> msg -> ( data, bdata )"},{"name":"ComponentMatcher","comment":" Component matcher type sugar\n","args":["data","bdata","tar"],"type":"data -> bdata -> tar -> Basics.Bool"},{"name":"ComponentStorage","comment":" Component storage type sugar\n","args":["cdata","userdata","tar","msg","bdata","scenemsg"],"type":"msg -> Messenger.Component.Component.LevelComponentStorage cdata userdata tar msg bdata scenemsg"},{"name":"ComponentUpdate","comment":" Component update type sugar\n","args":["cdata","data","userdata","scenemsg","tar","msg","bdata"],"type":"Messenger.Base.Env cdata userdata -> Messenger.Base.UserEvent -> data -> bdata -> ( ( data, bdata ), List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), ( Messenger.Base.Env cdata userdata, Basics.Bool ) )"},{"name":"ComponentUpdateRec","comment":" Component updaterec type sugar\n","args":["cdata","data","userdata","scenemsg","tar","msg","bdata"],"type":"Messenger.Base.Env cdata userdata -> msg -> data -> bdata -> ( ( data, bdata ), List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), Messenger.Base.Env cdata userdata )"},{"name":"ComponentView","comment":" Component view type sugar\n\nThe second entry is the \"z-index\" of the component.\n\n","args":["cdata","userdata","data","bdata"],"type":"Messenger.Base.Env cdata userdata -> data -> bdata -> ( Canvas.Renderable, Basics.Int )"},{"name":"ConcreteUserComponent","comment":" ConcreteUserComponent\n","args":["data","cdata","userdata","tar","msg","bdata","scenemsg"],"type":"Messenger.GeneralModel.ConcreteGeneralModel data (Messenger.Base.Env cdata userdata) Messenger.Base.UserEvent tar msg ( Canvas.Renderable, Basics.Int ) bdata (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"LevelComponentStorage","comment":" Level component storage type sugar\n","args":["cdata","userdata","tar","msg","bdata","scenemsg"],"type":"Messenger.Base.Env cdata userdata -> Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg"}],"values":[{"name":"genComponent","comment":" Generate abstract user component from concrete component.\n","type":"Messenger.Component.Component.ConcreteUserComponent data cdata userdata tar msg bdata scenemsg -> Messenger.Component.Component.ComponentStorage cdata userdata tar msg bdata scenemsg"},{"name":"genComponentsRenderList","comment":" Generate render list for one list of components.\n\nUseful when there are several component lists.\n\nThe output should be used as the input of `viewComponentsRenderList`.\n\n","type":"Messenger.Base.Env cdata userdata -> List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg) -> List.List ( Canvas.Renderable, Basics.Int )"},{"name":"updateComponents","comment":" Update a list of abstract user components.\n","type":"Messenger.Base.Env cdata userdata -> Messenger.Base.UserEvent -> List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg) -> ( List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg), List.List (Messenger.GeneralModel.MMsgBase msg scenemsg userdata), ( Messenger.Base.Env cdata userdata, Basics.Bool ) )"},{"name":"updateComponentsWithBlock","comment":" Update a list of abstract user components with block indicator.\n\nIt block is True, this function will not update anything.\n\n","type":"Messenger.Base.Env cdata userdata -> Messenger.Base.UserEvent -> Basics.Bool -> List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg) -> ( List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg), List.List (Messenger.GeneralModel.MMsgBase msg scenemsg userdata), ( Messenger.Base.Env cdata userdata, Basics.Bool ) )"},{"name":"updateComponentsWithTarget","comment":" Update a list of abstract user components with targeted msgs.\n","type":"Messenger.Base.Env cdata userdata -> List.List ( tar, msg ) -> List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg) -> ( List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg), List.List (Messenger.GeneralModel.MMsgBase msg scenemsg userdata), Messenger.Base.Env cdata userdata )"},{"name":"viewComponents","comment":" View one list of abstract components.\n\nUsed when there is only one list of components\n\n","type":"Messenger.Base.Env cdata userdata -> List.List (Messenger.Component.Component.AbstractComponent cdata userdata tar msg bdata scenemsg) -> Canvas.Renderable"},{"name":"viewComponentsRenderList","comment":" View the render list of components.\n\nUseful when there are several component lists.\n\nThe input should be generated by several `genComponentsRenderList`.\n\n","type":"List.List ( Canvas.Renderable, Basics.Int ) -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Coordinate.Coordinates","comment":"\n\n\n# Coordinate\n\nThis module deals with the coordinate transformation.\n\nThis module is very important because it can calculate the correct position of the point you want to draw.\n\n@docs fixedPosToReal\n@docs posToReal, posToVirtual\n@docs lengthToReal\n@docs fromRealLength\n@docs maxHandW\n@docs getStartPoint\n@docs judgeMouseRect\n@docs fromMouseToVirtual\n\n","unions":[],"aliases":[],"values":[{"name":"fixedPosToReal","comment":" fixedPosToReal\n\nSame as posToReal, but add the initial position of canvas.\n\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"},{"name":"fromMouseToVirtual","comment":" fromMouseToVirtual\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"},{"name":"fromRealLength","comment":" The inverse function of widthToReal.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> Basics.Float"},{"name":"getStartPoint","comment":" getStartPoint\n","type":"( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"},{"name":"judgeMouseRect","comment":" judgeMouseRect\nJudge whether the mouse position is in the rectangle.\n","type":"( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> Basics.Bool"},{"name":"lengthToReal","comment":" widthToReal\n\nUse this if you want to draw something based on the length.\n\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> Basics.Float"},{"name":"maxHandW","comment":" maxHandW\n","type":"( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"},{"name":"posToReal","comment":" posToReal\n\nTransform from the virtual coordinate system to the real pixel system.\n\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"},{"name":"posToVirtual","comment":" Inverse of posToReal.\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float )"}],"binops":[]},{"name":"Messenger.Coordinate.HTML","comment":"\n\n\n# HTML Coordinate Lib\n\nThis is only useful when you use extraHTML.\n\n@docs genAttribute\n\n","unions":[],"aliases":[],"values":[{"name":"genAttribute","comment":" Generate HTML Attributes that has the correct position\n\nUseful when you try to add extra HTML\n\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> List.List (Html.Attribute msg)"}],"binops":[]},{"name":"Messenger.GeneralModel","comment":"\n\n\n# General Model\n\nGeneral model is designed to be an abstract interface of layers, components, etc..\n\nA Gernel model has the ability to:\n\n  - specialize its own data types\n  - share some data types with objects in the same type\n  - be initialized by some inputs\n  - be updated by event and msgs\n  - be updated in a list of same type objects\n  - send msg to the objects in the same type\n  - send msg to the parent object\n  - render itself\n  - identify itself by a matcher\n\n@docs Msg, MsgBase\n@docs MMsg, MMsgBase\n@docs ConcreteGeneralModel, AbstractGeneralModel\n@docs MConcreteGeneralModel, MAbstractGeneralModel\n@docs unroll, abstract\n@docs viewModelList\n@docs Matcher\n\n","unions":[{"name":"AbstractGeneralModel","comment":" Rolled Abstract General Model.\n\nCannot be directedly modified.\nUsed for storage.\n\n","args":["env","event","tar","msg","ren","bdata","sommsg"],"cases":[["Roll",["Messenger.GeneralModel.UnrolledAbstractGeneralModel env event tar msg ren bdata sommsg"]]]},{"name":"Msg","comment":" The Basic Msg Model.\n\nUsing **Other** when sending msg to objects in the same type.\nMake sure the `othertar` can pass the matcher of target object.\n\n","args":["othertar","msg","sommsg"],"cases":[["Parent",["Messenger.GeneralModel.MsgBase msg sommsg"]],["Other",["( othertar, msg )"]]]},{"name":"MsgBase","comment":" MsgBase\n\nUsed when sending a msg to parent object.\n\nUsing **SOMMsg** when sending a `SceneOutputMsg`, which will be directedly handled by Top-level.\n\n","args":["othermsg","sommsg"],"cases":[["SOMMsg",["sommsg"]],["OtherMsg",["othermsg"]]]}],"aliases":[{"name":"ConcreteGeneralModel","comment":" Concrete General Model.\n\nUsers deal with the fields in concrete model.\n\n","args":["data","env","event","tar","msg","ren","bdata","sommsg"],"type":"{ init : env -> msg -> ( data, bdata ), update : env -> event -> data -> bdata -> ( ( data, bdata ), List.List (Messenger.GeneralModel.Msg tar msg sommsg), ( env, Basics.Bool ) ), updaterec : env -> msg -> data -> bdata -> ( ( data, bdata ), List.List (Messenger.GeneralModel.Msg tar msg sommsg), env ), view : env -> data -> bdata -> ren, matcher : data -> bdata -> tar -> Basics.Bool }"},{"name":"MAbstractGeneralModel","comment":" Specialized Abstract Model for Messenger\n","args":["common","userdata","tar","msg","bdata","scenemsg"],"type":"Messenger.GeneralModel.AbstractGeneralModel (Messenger.Base.Env common userdata) Messenger.Base.UserEvent tar msg Canvas.Renderable bdata (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"MConcreteGeneralModel","comment":" Specialized Concrete Model for Messenger\n","args":["data","common","userdata","tar","msg","bdata","scenemsg"],"type":"Messenger.GeneralModel.ConcreteGeneralModel data (Messenger.Base.Env common userdata) Messenger.Base.UserEvent tar msg Canvas.Renderable bdata (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"MMsg","comment":" Messenger Msg\n","args":["othertar","msg","scenemsg","userdata"],"type":"Messenger.GeneralModel.Msg othertar msg (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"MMsgBase","comment":" Messsenger MsgBase\n","args":["othermsg","scenemsg","userdata"],"type":"Messenger.GeneralModel.MsgBase othermsg (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata)"},{"name":"Matcher","comment":" A general matcher type sugar\n","args":["data","tar"],"type":"data -> tar -> Basics.Bool"}],"values":[{"name":"abstract","comment":" Abstract a concrete model to an abstract model.\n\nInitialize it with env and msg.\n\n","type":"Messenger.GeneralModel.ConcreteGeneralModel data env event tar msg ren bdata sommsg -> msg -> env -> Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg"},{"name":"unroll","comment":" Unroll a rolled abstract model.\n","type":"Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg -> Messenger.GeneralModel.UnrolledAbstractGeneralModel env event tar msg ren bdata sommsg"},{"name":"viewModelList","comment":" View model list.\n","type":"Messenger.Base.Env common userdata -> List.List (Messenger.GeneralModel.MAbstractGeneralModel common userdata tar msg bdata scenemsg) -> List.List Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Layer.Layer","comment":"\n\n\n# Layer\n\nGerneral Model and Helper functions for Layers.\n\n@docs ConcreteLayer, AbstractLayer\n\n\n## Generate\n\n@docs genLayer\n\n\n## Update\n\n@docs Handler\n@docs handleComponentMsgs\n@docs LayerInit, LayerUpdate, LayerUpdateRec, LayerView\n@docs LayerStorage\n\n","unions":[],"aliases":[{"name":"AbstractLayer","comment":" Abstract Layer Model.\n\nCannot be directedly modified.\nUsed for storage.\n\n","args":["cdata","userdata","tar","msg","scenemsg"],"type":"Messenger.GeneralModel.MAbstractGeneralModel cdata userdata tar msg () scenemsg"},{"name":"ConcreteLayer","comment":" Concrete Layer Model\n\nUsers deal with the fields in concrete model.\n\n","args":["data","cdata","userdata","tar","msg","scenemsg"],"type":"{ init : Messenger.Layer.Layer.LayerInit cdata userdata msg data, update : Messenger.Layer.Layer.LayerUpdate cdata userdata tar msg scenemsg data, updaterec : Messenger.Layer.Layer.LayerUpdateRec cdata userdata tar msg scenemsg data, view : Messenger.Layer.Layer.LayerView cdata userdata data, matcher : Messenger.GeneralModel.Matcher data tar }"},{"name":"Handler","comment":" Handler Type.\n\nA handler is used to handle the Component Msg sent to the layer.\n\n**Make handler for every type of component msg.**\n\n","args":["data","cdata","userdata","tar","msg","scenemsg","cmsg"],"type":"Messenger.Base.Env cdata userdata -> Messenger.GeneralModel.MMsgBase cmsg scenemsg userdata -> data -> ( data, List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), Messenger.Base.Env cdata userdata )"},{"name":"LayerInit","comment":" init type sugar\n","args":["cdata","userdata","msg","data"],"type":"Messenger.Base.Env cdata userdata -> msg -> data"},{"name":"LayerStorage","comment":" Layer Storage\n","args":["cdata","userdata","tar","msg","scenemsg"],"type":"msg -> Messenger.Base.Env cdata userdata -> Messenger.Layer.Layer.AbstractLayer cdata userdata tar msg scenemsg"},{"name":"LayerUpdate","comment":" update type sugar\n","args":["cdata","userdata","tar","msg","scenemsg","data"],"type":"Messenger.Base.Env cdata userdata -> Messenger.Base.UserEvent -> data -> ( data, List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), ( Messenger.Base.Env cdata userdata, Basics.Bool ) )"},{"name":"LayerUpdateRec","comment":" updaterec type sugar\n","args":["cdata","userdata","tar","msg","scenemsg","data"],"type":"Messenger.Base.Env cdata userdata -> msg -> data -> ( data, List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), Messenger.Base.Env cdata userdata )"},{"name":"LayerView","comment":" view type sugar\n","args":["cdata","userdata","data"],"type":"Messenger.Base.Env cdata userdata -> data -> Canvas.Renderable"}],"values":[{"name":"genLayer","comment":" Generate abstract layer by a concrete layer.\n\nInitialize it with env and msg.\n\n","type":"Messenger.Layer.Layer.ConcreteLayer data cdata userdata tar msg scenemsg -> Messenger.Layer.Layer.LayerStorage cdata userdata tar msg scenemsg"},{"name":"handleComponentMsgs","comment":" Handle a list of component msgs.\n\n**Note that for several list of component msgs with different types, you may have to use this function repeatedly.**\n\n","type":"Messenger.Base.Env cdata userdata -> List.List (Messenger.GeneralModel.MMsgBase cmsg scenemsg userdata) -> data -> List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata) -> Messenger.Layer.Layer.Handler data cdata userdata tar msg scenemsg cmsg -> ( data, List.List (Messenger.GeneralModel.MMsg tar msg scenemsg userdata), Messenger.Base.Env cdata userdata )"}],"binops":[]},{"name":"Messenger.Recursion","comment":"\n\n\n# RecursionList\n\nList implementation for the recursion algorithm\n\n@docs updateObjects, updateObjectsWithTarget\n\n","unions":[],"aliases":[],"values":[{"name":"updateObjects","comment":" Recursively update all the objects in the List\n","type":"env -> event -> List.List (Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg) -> ( List.List (Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg), List.List (Messenger.GeneralModel.MsgBase msg sommsg), ( env, Basics.Bool ) )"},{"name":"updateObjectsWithTarget","comment":" Recursively update all the objects in the List, but also uses target\n","type":"env -> List.List ( tar, msg ) -> List.List (Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg) -> ( List.List (Messenger.GeneralModel.AbstractGeneralModel env event tar msg ren bdata sommsg), List.List (Messenger.GeneralModel.MsgBase msg sommsg), env )"}],"binops":[]},{"name":"Messenger.Render.Shape","comment":"\n\n\n# Shape Rendering\n\n@docs circle, rect\n\n","unions":[],"aliases":[],"values":[{"name":"circle","comment":" Draw circle based on global data.\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> Basics.Float -> Canvas.Shape"},{"name":"rect","comment":" Draw rectangle based on global data.\n","type":"Messenger.Base.GlobalData a -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> Canvas.Shape"}],"binops":[]},{"name":"Messenger.Render.Sprite","comment":"\n\n\n# Sprite Rendering\n\n@docs renderSprite, renderSpriteWithRev\n@docs renderSpriteCropped\n\n","unions":[],"aliases":[],"values":[{"name":"renderSprite","comment":" Render a single sprite.\n","type":"Messenger.Base.GlobalData a -> List.List Canvas.Settings.Setting -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> String.String -> Canvas.Renderable"},{"name":"renderSpriteCropped","comment":" Render a single sprite with crop.\n","type":"Messenger.Base.GlobalData a -> List.List Canvas.Settings.Setting -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> { x : Basics.Float, y : Basics.Float, width : Basics.Float, height : Basics.Float } -> String.String -> Canvas.Renderable"},{"name":"renderSpriteWithRev","comment":" Render a single sprite with (possible) reverse.\n\nThe first argument is the reverse flag. Sent true to make the sprite being rendered in reverse.\n\n","type":"Basics.Bool -> Messenger.Base.GlobalData a -> List.List Canvas.Settings.Setting -> ( Basics.Float, Basics.Float ) -> ( Basics.Float, Basics.Float ) -> String.String -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Render.SpriteSheet","comment":"\n\n\n# Sprite Sheet\n\n@docs SingleSprite\n@docs SpriteSheet\n@docs spriteSheetSize\n\n","unions":[],"aliases":[{"name":"SingleSprite","comment":" A Single Sprite in a SpriteSheet\n\nThe unit of realSize is pixel.\n\n","args":[],"type":"{ realStartPoint : ( Basics.Float, Basics.Float ), realSize : ( Basics.Float, Basics.Float ) }"},{"name":"SpriteSheet","comment":" SpriteSheet\n\nUsers should both name the sprite sheets and every single sprite.\nUsing it by **format: \"sheet\\_name.sprite\\_name\"**\n\nSprite sheets are useful when managing the art resourses or making frame-by-frame animations.\n\n","args":[],"type":"Dict.Dict String.String (List.List ( String.String, Messenger.Render.SpriteSheet.SingleSprite ))"}],"values":[{"name":"spriteSheetSize","comment":" Get the total number of sprites in a sprite sheet.\n","type":"Messenger.Render.SpriteSheet.SpriteSheet -> Basics.Int"}],"binops":[]},{"name":"Messenger.Render.Text","comment":"\n\n\n# Text Rendering\n\n@docs renderText, renderTextWithStyle\n@docs renderTextWithColor, renderTextWithColorStyle\n@docs renderTextWithColorCenter, renderTextWithColorCenterStyle\n@docs renderTextWithColorAlignBaseline, renderTextWithColorAlignBaselineStyle\n@docs renderTextWithSettings, renderTextWithSettingsStyle\n\n","unions":[],"aliases":[],"values":[{"name":"renderText","comment":" Render Text. Black color, left top align.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColor","comment":" renderTextWithColor\nRender colorful texts.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColorAlignBaseline","comment":" Render texts with color, align and baseline.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> Canvas.Settings.Text.TextAlign -> Canvas.Settings.Text.TextBaseLine -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColorAlignBaselineStyle","comment":" Render texts with color, align and baseline.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> Canvas.Settings.Text.TextAlign -> Canvas.Settings.Text.TextBaseLine -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColorCenter","comment":" renderTextWithColorAlign\nRender texts with color and align.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColorCenterStyle","comment":" renderTextWithColorAlign\nRender texts with color and align.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithColorStyle","comment":" renderTextWithColor\nRender colorful texts.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> Color.Color -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithSettings","comment":" Use customized settings to render texts.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> List.List Canvas.Settings.Setting -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithSettingsStyle","comment":" Use customized settings to render texts.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> List.List Canvas.Settings.Setting -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"},{"name":"renderTextWithStyle","comment":" Render Text. Black color, left top align.\n","type":"Messenger.Base.GlobalData a -> Basics.Float -> String.String -> String.String -> String.String -> ( Basics.Float, Basics.Float ) -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Scene.LayeredScene","comment":"\n\n\n# Layered Scene\n\nLayered scene is a pre-defined scene implementation provided by Messenger.\nA layered scene can only handle a list of layers with fixed `cdata`, `userdata`, `tar`, `msg` and `scenemsg` types.\n\n@docs LayeredSceneData\n@docs genLayeredScene\n@docs LayeredSceneInit, LayeredSceneSettingsFunc\n\n\n## Scene Prototype\n\n@docs LayeredSceneProtoInit, LayeredSceneLevelInit, initCompose\n\n","unions":[],"aliases":[{"name":"LayeredSceneData","comment":" Layered Scene Data.\n\n    - `renderSettings` is used in `group` while viewing the layers as a whole\n    - `commonData` is the common data for the whole scene\n    - `layers` are the layers of the scene with type `AbstractLayer`\n\n","args":["cdata","userdata","tar","msg","scenemsg"],"type":"{ renderSettings : List.List Canvas.Settings.Setting, commonData : cdata, layers : List.List (Messenger.Layer.Layer.AbstractLayer cdata userdata tar msg scenemsg) }"},{"name":"LayeredSceneInit","comment":" init type sugar\n","args":["cdata","userdata","tar","msg","scenemsg"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> Messenger.Scene.LayeredScene.LayeredSceneData cdata userdata tar msg scenemsg"},{"name":"LayeredSceneLevelInit","comment":" init type sugar for levels\n","args":["userdata","scenemsg","idata"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> Maybe.Maybe idata"},{"name":"LayeredSceneProtoInit","comment":" init type sugar for scene prototypes\n","args":["cdata","userdata","tar","msg","scenemsg","idata"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe idata -> Messenger.Scene.LayeredScene.LayeredSceneData cdata userdata tar msg scenemsg"},{"name":"LayeredSceneSettingsFunc","comment":" settingsFunc type sugar\n","args":["cdata","userdata","tar","msg","scenemsg"],"type":"Messenger.Base.Env () userdata -> Messenger.Base.UserEvent -> Messenger.Scene.LayeredScene.LayeredSceneData cdata userdata tar msg scenemsg -> List.List Canvas.Settings.Setting"}],"values":[{"name":"genLayeredScene","comment":" This creates a layered scene.\n\n  - `init` creates the initial layered scene from env data and init msg.\n  - `settingsFunc` is a user provided function to modify `renderSettings` each time the scene updates. If you don't need `settingsFunc`, simply provide a `func _ _ _ = settings`\n\n","type":"Messenger.Scene.LayeredScene.LayeredSceneInit cdata userdata tar msg scenemsg -> Messenger.Scene.LayeredScene.LayeredSceneSettingsFunc cdata userdata tar msg scenemsg -> Messenger.Scene.Scene.SceneStorage userdata scenemsg"},{"name":"initCompose","comment":" Compose LayeredSceneProtoInit with LayeredSceneLevelInit.\n","type":"Messenger.Scene.LayeredScene.LayeredSceneProtoInit cdata userdata tar msg scenemsg idata -> Messenger.Scene.LayeredScene.LayeredSceneLevelInit userdata scenemsg idata -> Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> Messenger.Scene.LayeredScene.LayeredSceneData cdata userdata tar msg scenemsg"}],"binops":[]},{"name":"Messenger.Scene.RawScene","comment":"\n\n\n# RawScene\n\nRaw Scene is a scene without anything. Users can add whatever they like in the raw scene!\n\n@docs RawSceneInit, RawSceneUpdate, RawSceneView\n@docs genRawScene\n\n\n## Scene Prototype\n\n@docs RawSceneProtoInit, RawSceneProtoLevelInit, initCompose\n\n","unions":[],"aliases":[{"name":"RawSceneInit","comment":" init type sugar\n","args":["data","userdata","scenemsg"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> data"},{"name":"RawSceneProtoInit","comment":" init type sugar for scene prototypes\n","args":["data","userdata","idata"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe idata -> data"},{"name":"RawSceneProtoLevelInit","comment":" init type sugar for levels\n","args":["userdata","scenemsg","idata"],"type":"Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> Maybe.Maybe idata"},{"name":"RawSceneUpdate","comment":" update type sugar\n","args":["data","userdata","scenemsg"],"type":"Messenger.Base.Env () userdata -> Messenger.Base.UserEvent -> data -> ( data, List.List (Messenger.Scene.Scene.SceneOutputMsg scenemsg userdata), Messenger.Base.Env () userdata )"},{"name":"RawSceneView","comment":" view type sugar\n","args":["userdata","data"],"type":"Messenger.Base.Env () userdata -> data -> Canvas.Renderable"}],"values":[{"name":"genRawScene","comment":" Generate a raw scene from a concrete scene.\n","type":"Messenger.Scene.Scene.MConcreteScene data userdata scenemsg -> Messenger.Scene.Scene.SceneStorage userdata scenemsg"},{"name":"initCompose","comment":" Compose RawSceneProtoInit with RawSceneProtoLevelInit.\n","type":"Messenger.Scene.RawScene.RawSceneProtoInit data userdata idata -> Messenger.Scene.RawScene.RawSceneProtoLevelInit userdata scenemsg idata -> Messenger.Base.Env () userdata -> Maybe.Maybe scenemsg -> data"}],"binops":[]},{"name":"Messenger.Scene.Scene","comment":"\n\n\n# Scene Base\n\nGerneral Model and Basic types for Scenes\n\n@docs AbstractScene\n@docs MConcreteScene, MAbstractScene\n@docs unroll, abstract\n@docs SceneOutputMsg\n@docs SceneStorage, AllScenes\n@docs SceneContext\n\n","unions":[{"name":"AbstractScene","comment":" Rolled Abstract Scene Model.\n\nCannot be directedly modified.\nUsed for storage.\n\n","args":["env","event","ren","scenemsg","userdata"],"cases":[["Roll",["Messenger.Scene.Scene.UnrolledAbstractScene env event ren scenemsg userdata"]]]},{"name":"SceneOutputMsg","comment":" Scene Output Msg is the message that directedly handled by the top-level core.\n\n`scenemsg` is a custom type which represents the message type users wants\nto send to a scene when switching scenes.\n\n  - `SOMChangeScene` is used to change to a target scene by giving a **initMsg name trasition**\n  - `SOMPlayAudio channel name option` is used to play an audio resource by giving **channel name option**\n  - `SOMStopAudio` is used to stop a playing audio by giving its **name**\n  - `SOMSetVolume` is used to set the volume with a value **from 0 to 1**\n  - `SOMAlert` makes an alert\n  - `SOMPromp name title` makes a prompt with **name title**\n  - `SOMSaveGlobalData` saves the global by encode funtion given in UserConfig\n  - `SOMSetContext` restores the context of the scene\n  - `SOMGetContext` gets the context of the scene\n\n","args":["scenemsg","userdata"],"cases":[["SOMChangeScene",["Maybe.Maybe scenemsg","String.String","Maybe.Maybe (Messenger.Scene.Transitions.Base.Transition userdata)"]],["SOMAlert",["String.String"]],["SOMPrompt",["String.String","String.String"]],["SOMPlayAudio",["Basics.Int","String.String","Messenger.Audio.Base.AudioOption"]],["SOMStopAudio",["Basics.Int"]],["SOMSetVolume",["Basics.Float"]],["SOMSaveGlobalData",[]],["SOMSetContext",["Messenger.Scene.Scene.SceneContext userdata scenemsg"]],["SOMGetContext",["Messenger.Scene.Scene.SceneContext userdata scenemsg -> userdata -> userdata"]]]}],"aliases":[{"name":"AllScenes","comment":" All scenes type\n","args":["userdata","scenemsg"],"type":"List.List ( String.String, Messenger.Scene.Scene.SceneStorage userdata scenemsg )"},{"name":"MAbstractScene","comment":" Specialized Abstract scene for Messenger\n","args":["userdata","scenemsg"],"type":"Messenger.Scene.Scene.AbstractScene (Messenger.Base.Env () userdata) Messenger.Base.UserEvent Canvas.Renderable scenemsg userdata"},{"name":"MConcreteScene","comment":" Specialized Concrete scene for Messenger\n","args":["data","userdata","scenemsg"],"type":"Messenger.Scene.Scene.ConcreteScene data (Messenger.Base.Env () userdata) Messenger.Base.UserEvent Canvas.Renderable scenemsg userdata"},{"name":"SceneContext","comment":" Scene Context\n","args":["userdata","scenemsg"],"type":"{ scene : Messenger.Scene.Scene.MAbstractScene userdata scenemsg, sceneStartTime : Basics.Int, sceneStartFrame : Basics.Int, name : String.String }"},{"name":"SceneStorage","comment":" The type used to store the scene data.\n","args":["userdata","scenemsg"],"type":"Maybe.Maybe scenemsg -> Messenger.Base.Env () userdata -> Messenger.Scene.Scene.MAbstractScene userdata scenemsg"}],"values":[{"name":"abstract","comment":" Abstract a concrete scene to an abstract scene.\n\nInitialize it with env and msg.\n\n","type":"Messenger.Scene.Scene.ConcreteScene data env event ren scenemsg userdata -> Maybe.Maybe scenemsg -> env -> Messenger.Scene.Scene.AbstractScene env event ren scenemsg userdata"},{"name":"unroll","comment":" Unroll a rolled abstract scene.\n","type":"Messenger.Scene.Scene.AbstractScene env event ren scenemsg userdata -> Messenger.Scene.Scene.UnrolledAbstractScene env event ren scenemsg userdata"}],"binops":[]},{"name":"Messenger.Scene.Transition","comment":"\n\n\n# Transtition Library\n\n@docs makeTransition\n\n","unions":[],"aliases":[],"values":[{"name":"makeTransition","comment":" Generate transition from transition data.\n","type":"Messenger.Base.GlobalData a -> Maybe.Maybe (Messenger.Scene.Transitions.Base.Transition a) -> Canvas.Renderable -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Scene.Transitions.Base","comment":"\n\n\n# Transition Base\n\n@docs Transition, SingleTrans\n@docs genTransition, nullTransition\n\n","unions":[],"aliases":[{"name":"SingleTrans","comment":" Single Transition\n","args":["userdata"],"type":"Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"},{"name":"Transition","comment":" Transition has two stages:\n\n1.  From the old scene to the transition scene\n2.  From the transition scene to the new scene\n\n","args":["userdata"],"type":"{ currentTransition : Basics.Int, outT : Basics.Int, inT : Basics.Int, outTrans : Messenger.Scene.Transitions.Base.SingleTrans userdata, inTrans : Messenger.Scene.Transitions.Base.SingleTrans userdata }"}],"values":[{"name":"genTransition","comment":" Generate new transition\n","type":"( Messenger.Scene.Transitions.Base.SingleTrans userdata, Duration.Duration ) -> ( Messenger.Scene.Transitions.Base.SingleTrans userdata, Duration.Duration ) -> Messenger.Scene.Transitions.Base.Transition userdata"},{"name":"nullTransition","comment":" Null Transition\n","type":"Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Scene.Transitions.Fade","comment":" Fading Effects\n\n@docs fadeIn, fadeOut\n@docs fadeOutBlack, fadeInBlack\n@docs fadeOutWithRenderable, fadeInWithRenderable\n\n","unions":[],"aliases":[],"values":[{"name":"fadeIn","comment":" Fade In with Color\n","type":"Color.Color -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"},{"name":"fadeInBlack","comment":" Fade In with Black\n","type":"Messenger.Scene.Transitions.Base.SingleTrans userdata"},{"name":"fadeInWithRenderable","comment":" Fade In with Renderable\n","type":"Canvas.Renderable -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"},{"name":"fadeOut","comment":" Fade Out with Color\n","type":"Color.Color -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"},{"name":"fadeOutBlack","comment":" Fade Out with Black\n","type":"Messenger.Scene.Transitions.Base.SingleTrans userdata"},{"name":"fadeOutWithRenderable","comment":" Fade Out with Renderable\n","type":"Canvas.Renderable -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.Scene.Transitions.Scroll","comment":" Scroll Transition\n\n@docs scrollIn, scrollOut\n\n","unions":[],"aliases":[],"values":[{"name":"scrollIn","comment":" Scroll In\n","type":"Color.Color -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"},{"name":"scrollOut","comment":" Scroll Out\n","type":"Color.Color -> Messenger.Base.GlobalData userdata -> Canvas.Renderable -> Basics.Float -> Canvas.Renderable"}],"binops":[]},{"name":"Messenger.UI","comment":"\n\n\n# User Interface\n\nTop-level user interface to the Messenger engine.\n\n@docs Output\n@docs genMain\n\n","unions":[],"aliases":[{"name":"Output","comment":" The output of the Messenger UI.\n","args":["userdata","scenemsg"],"type":"Platform.Program Messenger.Base.Flags (Audio.Model Messenger.Base.WorldEvent (Messenger.Model.Model userdata scenemsg)) (Audio.Msg Messenger.Base.WorldEvent)"}],"values":[{"name":"genMain","comment":" Generate the main program (output) from input.\n\n**Use this for your main function**\n\n","type":"Messenger.UI.Input.Input userdata scenemsg -> Messenger.UI.Output userdata scenemsg"}],"binops":[]},{"name":"Messenger.UI.Input","comment":"\n\n\n# Input to the Messenger UI\n\n@docs Input\n\n","unions":[],"aliases":[{"name":"Input","comment":" The input to the Messenger UI.\n","args":["userdata","scenemsg"],"type":"{ config : Messenger.UserConfig.UserConfig userdata scenemsg, resources : Messenger.UserConfig.Resources, scenes : Messenger.Scene.Scene.AllScenes userdata scenemsg }"}],"values":[],"binops":[]},{"name":"Messenger.UserConfig","comment":"\n\n\n# User Configuration\n\n@docs TimeInterval\n@docs UserConfig, PortDefs\n@docs coloredBackground, transparentBackground\n@docs Resources\n@docs resourceNum\n\n","unions":[{"name":"TimeInterval","comment":" Time interval between every two frames.\n\n  - `Fixed` represents the fixed time interval between every two frames.\n    The value is the time interval in milliseconds.\n  - `Animation` will use the browser's `requestAnimationFrame` to update the game.\n    The frame rate will be dependent on your device. This will make the animation looks smoother.\n\n","args":[],"cases":[["Fixed",["Basics.Float"]],["Animation",[]]]}],"aliases":[{"name":"PortDefs","comment":" The ports that the user must provide to the messenger.\n\n**Learn more about ports [here](https://guide.elm-lang.org/interop/ports)**\n\n","args":[],"type":"{ sendInfo : String.String -> Platform.Cmd.Cmd Messenger.Base.WorldEvent, audioPortToJS : Json.Encode.Value -> Platform.Cmd.Cmd (Audio.Msg Messenger.Base.WorldEvent), audioPortFromJS : (Json.Decode.Value -> Audio.Msg Messenger.Base.WorldEvent) -> Platform.Sub.Sub (Audio.Msg Messenger.Base.WorldEvent), alert : String.String -> Platform.Cmd.Cmd Messenger.Base.WorldEvent, prompt : { name : String.String, title : String.String } -> Platform.Cmd.Cmd Messenger.Base.WorldEvent, promptReceiver : ({ name : String.String, result : String.String } -> Messenger.Base.WorldEvent) -> Platform.Sub.Sub Messenger.Base.WorldEvent }"},{"name":"Resources","comment":" Resources\n\n  - `allTexture` stores all the texture assets users will use in the game. The path is based on the project folder.\n    **format: Dict name path**\n  - `allSpriteSheets` stores all the sprite sheets users set for this game. users should both\n    name the sprite sheets and every single sprite. Using it by **format: \"sheet\\_name.sprite\\_name\"**\n    Sprite sheets are useful when managing the art recourses or making frame-by-frame animations\n  - `allAudio` stores all the audio assets users will use in the game. **format: Dict name path**\n\n","args":[],"type":"{ allTexture : Dict.Dict String.String String.String, allAudio : Dict.Dict String.String String.String, allSpriteSheets : Messenger.Render.SpriteSheet.SpriteSheet }"},{"name":"UserConfig","comment":" User Configuration for the messenger.\n\n`userdata` is a custom type which can store any data in the game.\nusers can **save their own global data** and **implement local storage** here.\n\n`scenemsg` is another custom type which represents the message type users wants\nto send to a scene when switching scenes.\n\n  - `initScene` represents the scene users get start\n  - `initSceneMsg` represents the message to initialize the start scene\n  - `globalDataCodec` is for local storage, users can encode the any data in global data\n    and user data to storage them, and decode them when reopen the game.\n    This globalData is a subset of the real global data, removing all internal data structures\n  - `virtualSize` represents how users want their game be virtual sized. In other words,\n    users make their game in the virtual size, and the game will be resized due to the browser window size\n    but keeping the aspect ratio\n  - `debug` option determines whether enable some simple debugging tools or not\n    remember to disable it when releasing game\n  - `background` determines the background of the game\n    transparent background and colored background is already prepared\n  - `timeInterval` See `TimeInterval`\n  - `ports` stores the ports that users must provide.\n\n","args":["userdata","scenemsg"],"type":"{ initScene : String.String, initSceneMsg : Maybe.Maybe scenemsg, globalDataCodec : { encode : Messenger.Base.UserViewGlobalData userdata -> String.String, decode : String.String -> Messenger.Base.UserViewGlobalData userdata }, virtualSize : { width : Basics.Float, height : Basics.Float }, debug : Basics.Bool, background : Messenger.Base.GlobalData userdata -> Canvas.Renderable, timeInterval : Messenger.UserConfig.TimeInterval, ports : Messenger.UserConfig.PortDefs }"}],"values":[{"name":"coloredBackground","comment":" A colored background.\n","type":"Color.Color -> Messenger.Base.GlobalData userdata -> Canvas.Renderable"},{"name":"resourceNum","comment":" The number of sprites in the game.\n","type":"Messenger.UserConfig.Resources -> Basics.Int"},{"name":"transparentBackground","comment":" A transparent background. You should use this for release.\n","type":"Messenger.Base.GlobalData userdata -> Canvas.Renderable"}],"binops":[]}]